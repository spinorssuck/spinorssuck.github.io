<!DOCTYPE html> <html lang="en"> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title>A Note on Quantum Approximate Counting and Random Musings | Rithvik Reddy Golamari</title> <meta name="author" content="Rithvik Reddy Golamari"> <meta name="description" content="A simple, whitespace theme for academics. Based on [*folio](https://github.com/bogoli/-folio) design. "> <meta name="keywords" content="jekyll, jekyll-theme, academic-website, portfolio-website"> <link rel="stylesheet" href="/assets/css/bootstrap.min.css?a4b3f509e79c54a512b890d73235ef04"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"> <link defer rel="stylesheet" href="https://unpkg.com/bootstrap-table@1.22.1/dist/bootstrap-table.min.css"> <link rel="stylesheet" href="/assets/css/academicons.min.css?f0b7046b84e425c55f3463ac249818f5"> <link rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons"> <link rel="stylesheet" href="/assets/css/jekyll-pygments-themes-github.css?19f3075a2d19613090fe9e16b564e1fe" media="" id="highlight_theme_light"> <link href="/assets/css/bootstrap-toc.min.css?6f5af0bb9aab25d79b2448143cbeaa88" rel="stylesheet"> <link rel="shortcut icon" href="data:image/svg+xml,&lt;svg%20xmlns=%22http://www.w3.org/2000/svg%22%20viewBox=%220%200%20100%20100%22&gt;&lt;text%20y=%22.9em%22%20font-size=%2290%22&gt;%E2%9A%9B%EF%B8%8F&lt;/text&gt;&lt;/svg&gt;"> <link rel="stylesheet" href="/assets/css/main.css?d41d8cd98f00b204e9800998ecf8427e"> <link rel="canonical" href="https://spinorssuck.github.io/blog/2020/quantumcounting/"> <link rel="stylesheet" href="/assets/css/jekyll-pygments-themes-native.css?e74e74bf055e5729d44a7d031a5ca6a5" media="none" id="highlight_theme_dark"> <script src="/assets/js/theme.js?6185d15ea1982787ad7f435576553d64"></script> </head> <body class="fixed-top-nav "> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="/"><span class="font-weight-bold">Rithvik </span>Reddy Golamari</a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/">about</a> </li> <li class="nav-item "> <a class="nav-link" href="/blog/">blog</a> </li> <li class="nav-item "> <a class="nav-link" href="/projects/">projects</a> </li> <li class="nav-item "> <a class="nav-link" href="/cv/">cv</a> </li> <li class="nav-item "> <a class="nav-link" href="/people/">people</a> </li> <li class="toggle-container"> <button id="light-toggle" title="Change theme"> <i class="fa-solid fa-moon"></i> <i class="fa-solid fa-sun"></i> </button> </li> </ul> </div> </div> </nav> <progress id="progress" value="0"> <div class="progress-container"> <span class="progress-bar"></span> </div> </progress> </header> <div class="container mt-5"> <div class="row"> <div class="col-sm-3"> <nav id="toc-sidebar" class="sticky-top"></nav> </div> <div class="col-sm-9"> <div class="post"> <header class="post-header"> <h1 class="post-title">A Note on Quantum Approximate Counting and Random Musings</h1> <p class="post-meta">July 17, 2020</p> <p class="post-tags"> <a href="/blog/2020"> <i class="fa-solid fa-calendar fa-sm"></i> 2020 </a>   ·   <a href="/blog/tag/quantum-computing"> <i class="fa-solid fa-hashtag fa-sm"></i> quantum-computing</a>   <a href="/blog/tag/quantum"> <i class="fa-solid fa-hashtag fa-sm"></i> quantum</a>     ·   <a href="/blog/category/math"> <i class="fa-solid fa-tag fa-sm"></i> math</a>   </p> </header> <article class="post-content"> <div id="markdown-content"> <h2 id="introduction">Introduction</h2> <p>Ok, today we’ll tackle something that I’ve never talked about in my blog before:Quantum computing.There might be a few more quantum computing posts in the future if I am in the mood for it.</p> <p>The problem at hand is simple: There is an unordered list of \(N\) items of which \(K\) are marked;Approximate the value of \(K\). Throughout, we’ll represent the \(N\) items by \([N]\) and the \(K items\) by \([K]\).</p> <p>This is actually a rather old problem which has been tackled before, and is deeply connected to amplitude estimation(see [1]) which uses uses the Quantum Fourier transform. Recently though, a simpler proof which uses only Grover-like techniques was published by Scott Aaronson, a professor at UT Austin(Hook em’ Horns!). Note that the algorithm is probabilistic with no bounds.</p> <p>The heart of the technique is Grover’s algorithm so perhaps I should spend a few words on that. Consider an unordered list of size \(N\) where you want to find a particular element which can be checked to be a solution in constant time, then this can be found in \(O(\sqrt{N})\).</p> <p>In the classical case, one is forced to do this(both the above problem and QAC) in \(O(n)\) time. The full strength of Grover’s algorithm is that one can actually find the pre-image \(f^{-1}(b)\) for \(f:[N] \to \{0,1\}\) where \(f\) maps \(x\) to \(1\) if and only if \(x\) is a solution to the given problem. This is all encoded as a quantum black-box unitary operator \(U\) defined by \(U\vert x \rangle =\vert x \rangle\) if \(f(x)=0\) and \(U\vert x \rangle=-\vert x \rangle\) if \(f(x)=1\).</p> <p>The idea of the algorithm is that we spit out the the superposition of all states:</p> \[\vert s \rangle =\frac{1}{\sqrt{N}} \sum\limits_{i=1}^{N} \vert x \rangle\] <p>followed by applying the operator \(U\) above which selects the marked item by flipping it.</p> <p>and then apply the diffusion operator :</p> <p>\(D=2 \vert s \rangle \langle s \vert-I\). This, in effect, flips the marked qubit around the mean, selectively increasing its relative amplitude.</p> <p>Explicitly, the mapping of the diffusion gate is:</p> <p>\(\sum\limits_{x \in \{0,1\}^{n}}\alpha_{x}\vert x \rangle \mapsto \sum\limits_{x \in \{0,1\}^{n}}(2\mu-\alpha_{x})\) where \(\mu\) is the mean of the \(\vert x \rangle\).</p> <p>One repeats this a certain number of times(specifically \(O(\sqrt{N})\) and then measures, obtaining the corresponding eigenvalue with high probability.</p> <h2 id="a-random-aside">A Random Aside?</h2> <p>In the case of a non-local hidden-variable quantum computer, one can actually do this in atmost \(O(\sqrt[3]{N})\) time. I’m not really going to talk about this. However, this spawned a simple question:What if you could perform it in \(O(log(N))\) time? What would that actually imply?</p> <p>Consider the SAT problem: There are variables \(x_{1},\cdots,x_{n}\) and expressions in these variables \(l_{1},\cdots,l_{k}\). Find an assignment of either true/false to each \(x_{i}\) such that all the expressions \(l_{p}\) evaluate to true.,i.e \(l_{1} \land l_{2} \land \cdots \land l_{k}\) is true.</p> <p>Anyways, we can store all \(O(2^{n})\) possibilities and search through them in \(O(log(2^{n}))=O(n)\) time in our hypothetical case, which is linear. This would mean that confirmed NP decision problems like \(SAT\), Hamiltonian path problem can be solved in polynomial time which implies \(P=NP\). So, it is unlikely that this is the case.</p> <p>I’ll get back to the these things in the end of this post.</p> <h2 id="quantum-approximate-counting">Quantum Approximate Counting</h2> <p>Consider an unordered collection of size \(N\) where \(K\) of them is marked. Estimate the value of \(K\). This is the problem at hand.</p> <p>Firstly, let’s clarify the exact problem statement. We wish to find an approxiamte solution, so that means we select multiplicative error \(\epsilon\), i.e find \(\tilde{K}\) such that</p> \[1-\epsilon \leq \frac{\tilde{K}}{K} \leq 1+\epsilon\] <p>Moreover, the algorithm is supposed to be probabilistic so we also select a small probability of failure \(\delta\).</p> <p>Let’s first review some obvious solutions before getting to the actual algorithm. One must note that in the case of a quantum solution, we only care about how many query calls we make,i.e the query call complexity. The real difference in these cases is that in a quantum computer, we can measure observables and get a probability distribution of measurements, so we want to make clever choices for the observables that we measure to extract useful information, the same philosophy behind Grover’s algorithm. As such, it seems reasonable that in a good solution, the query call complexity depends somehow on the value \(K\) itself.</p> <h2 id="classical-solution">Classical solution</h2> <p>To exactly find \(K\), the only choice is a linear search which is \(O(n)\). Actually, the approximate case(deterministic) could be done in \(O(\frac{1}{\epsilon^{2}}\frac{N}{K})\).</p> <h2 id="easy-quantum-solution">‘Easy’ quantum solution</h2> <p>Use Grover’s algorithm where \(f\) maps the input to \(1\) if and only if it is marked, this would be \(O(\sqrt{N})\).</p> <p>Query call complexity of the ideal solution</p> <p>Perhaps, it is best if I reveal the complexity before moving on. The ideal ideal query call complexity to obtain \(\tilde{K}\) which \(\epsilon-approximates\) \(K\) with high probability of success \(1-\delta\) is \(O(\frac{1}{\epsilon} \sqrt{\frac{N}{K}} log(\frac{1}{\delta}))\).</p> <h2 id="initial-steps">Initial steps</h2> <p>Instead of approximating \(K\), we equivalently approxiamte \(\theta = arcsin(\frac{N}{K})\).</p> <p>There are really two steps:</p> <p>First, we find a good constant-factor approximation to \(K\) and then we cleverly shave off the bounds to get an \(\epsilon -approximation\).</p> <p>So, first we obtain some interval \([\theta_{min}^{t+1},\theta_{max}^{t-1}]\) containing \(\theta\).</p> <p>This is explained in part 1 of Aaronson’s overview of the algorithm:</p> <p>Here , \(\phi\) is the uniform superposition of all states and \(G\) is the diffusion operator</p> <p>Note that :</p> <p>\(G^{\frac{r-1}{2}}\vert \psi \rangle=\frac{sin(r\theta)}{\sqrt{K}} \sum\limits_{x \in [K] } \vert x \rangle +\frac{cos(r\theta)}{\sqrt{K}} \sum\limits_{x \not\in [K]} \vert x \rangle\). In the computational basis, the probability of measuring a marked item is \(sin^{2}(r\theta)\). Step 1 essentially returns a constant factor approxiamtion to \(\theta\) withhigh probability. This can be proven using Chernoff bounds which I’ll omit from the discussion.</p> <p>It is also proven in page 5 that with high probability, one will not find enough marked items to finish step 1 before \(t&lt;t_{0}\). Also, with high probability, we’ll see enough marked items in \(t=t_{0},t_{0}+1\).The interesting part is how to get an \(\epsilon-approximation\).</p> <h2 id="final-solution">Final solution</h2> <p>Now, that we have \(\theta_{min},\theta_{max}\), we use the following clever result on page 9:</p> <p>Let \(0&lt;\theta_{min}\leq \theta\leq \theta_{max} \leq \frac{\pi}{1000} and\) \theta_{max}=\theta_{min}(1+\gamma) \(where\) \gamma \leq \frac{1}{5} \(. There exists an integer\) r $$ such that the following is true:</p> <p>Consider tossing a biased coin which is heads with probability \(sin^{2}(r\theta)\) at least \(1000.ln(\frac{1}{\epsilon})\) times.</p> <p>If more heads are observed, set \(\theta_{min}:=\frac{\theta_{max}}{1+0.9 \gamma}\) else set</p> <p>\(\theta_{max}:=\theta_{min}(1+0.9\gamma)\).</p> <p>This process fails to maintain \(\theta_{min} \leq \theta \leq \theta_{max}\) with low probability \(\gamma\). The value \(r\) also has some non-trivial bounds.</p> <p>The probability of getting heads above is exactly the probability of getting a marked item in \(G^{\frac{r-1}{2}}\vert \psi \rangle\) above.</p> <p>The upshot is that we can distinguish \(\theta_{min},\theta_{max}\) by measurement by considering instead \(r\theta_{min},r\theta_{max}\) which are nearly orthogonal. Based on our results of measurement, we shave-off either \(\theta_{min}\) or \(\theta_{max}\) by a factor of \(0.9\) getting closer and closer(with high probability) to our required \(\epsilon-\)estimate of \(\theta\).</p> <h2 id="philosophical-musings-on-energy-and-algorithms">Philosophical musings on Energy and Algorithms</h2> <p>I beg the reader to ignore everything here and close this tab immediately as I have no idea what I’m saying(not that I ever do).</p> <p>Recently, I came across a few interesting thins=gs:</p> <p>One was an experimental method to tackle classic difficult computer science problems. One was using chemical reactions with DNA molecules to solve the Hamiltonian path problem which is NP-hard. The problem was that it requires an amount factorial in the number of vertices to work. Another solution uses an optical contraption of cables and beam splitters to get a solution. Again, the drawback is that amount of required energy is exponential in the number of vertices. There is another example of some kind of a bizarre mold which rearranges itself in a manner to give an approximate solution to the Travelling Salesman Problem.</p> <p>In fact, there is an entire field of DNA computing. The aim is to use parallel computing to optimize our solutions. The drawback is that the processing speed is slow.</p> <p>Again, even for Grover’s algorithm, note that we must first ‘store’/obtain the entire quantum state itself unlike a classic linear-search where the auxilliry space needed is 1. Within a certain degree(spanning all these systems of computing), it seems that we can, to SOME degree, substitute time for space/energy.An obvious thing to note is that you can’t decide anything about some new data if you haven’t even stored it. More often than not, we are willing to make this sacrifice because we care more for efficiency.</p> <p>Parallel computing speedups require increasing the number of components. Of course, there is Amdahl’s law which puts some kind of a restriction to this.</p> <p>Aaronson talked about this in one of his informal talks(I think an interview or TedTalk).</p> <p>The study of complexity theory really may reveal things about physics, nature and energy it seems. In classical computing, there is a limit to how much we can trade space for time so we consider other unconventional types of computing where the threshold for this tradeoff is higher. This is truly an interesting direction to think in.</p> </div> </article> </div> </div> </div> </div> <footer class="fixed-bottom"> <div class="container mt-0"> © Copyright 2024 Rithvik Reddy Golamari. Powered by <a href="https://jekyllrb.com/" target="_blank" rel="external nofollow noopener">Jekyll</a> with <a href="https://github.com/alshedivat/al-folio" rel="external nofollow noopener" target="_blank">al-folio</a> theme. Hosted by <a href="https://pages.github.com/" target="_blank" rel="external nofollow noopener">GitHub Pages</a>. Photos from <a href="https://unsplash.com" target="_blank" rel="external nofollow noopener">Unsplash</a>. </div> </footer> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script src="/assets/js/bootstrap.bundle.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/masonry-layout@4.2.2/dist/masonry.pkgd.min.js" integrity="sha256-Nn1q/fx0H7SNLZMQ5Hw5JLaTRZp0yILA/FRexe19VdI=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/imagesloaded@4/imagesloaded.pkgd.min.js"></script> <script defer src="/assets/js/masonry.js" type="text/javascript"></script> <script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.0.8/dist/medium-zoom.min.js" integrity="sha256-7PhEpEWEW0XXQ0k6kQrPKwuoIomz8R8IYyuU1Qew4P8=" crossorigin="anonymous"></script> <script defer src="/assets/js/zoom.js?7b30caa5023af4af8408a472dc4e1ebb"></script> <script defer src="/assets/js/bootstrap-toc.min.js?c82ff4de8b0955d6ff14f5b05eed7eb6"></script> <script defer src="https://unpkg.com/bootstrap-table@1.22.1/dist/bootstrap-table.min.js"></script> <script src="/assets/js/no_defer.js?d633890033921b33e0ceb13d22340a9c"></script> <script defer src="/assets/js/common.js?acdb9690d7641b2f8d40529018c71a01"></script> <script defer src="/assets/js/copy_code.js?9b43d6e67ddc7c0855b1478ee4c48c2d" type="text/javascript"></script> <script async src="https://d1bxh8uas1mnw7.cloudfront.net/assets/embed.js"></script> <script async src="https://badge.dimensions.ai/badge.js"></script> <script type="text/javascript">window.MathJax={tex:{tags:"ams"}};</script> <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.0/es5/tex-mml-chtml.js"></script> <script defer src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script> <script type="text/javascript">function progressBarSetup(){"max"in document.createElement("progress")?(initializeProgressElement(),$(document).on("scroll",function(){progressBar.attr({value:getCurrentScrollPosition()})}),$(window).on("resize",initializeProgressElement)):(resizeProgressBar(),$(document).on("scroll",resizeProgressBar),$(window).on("resize",resizeProgressBar))}function getCurrentScrollPosition(){return $(window).scrollTop()}function initializeProgressElement(){let e=$("#navbar").outerHeight(!0);$("body").css({"padding-top":e}),$("progress-container").css({"padding-top":e}),progressBar.css({top:e}),progressBar.attr({max:getDistanceToScroll(),value:getCurrentScrollPosition()})}function getDistanceToScroll(){return $(document).height()-$(window).height()}function resizeProgressBar(){progressBar.css({width:getWidthPercentage()+"%"})}function getWidthPercentage(){return getCurrentScrollPosition()/getDistanceToScroll()*100}const progressBar=$("#progress");window.onload=function(){setTimeout(progressBarSetup,50)};</script> </body> </html>